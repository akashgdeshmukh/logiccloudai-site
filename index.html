<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Orbit with Multiple Logos</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow-x: hidden;
      background: #0A0A2A;
      height: 200vh;
      width: 100vw;
      font-family: sans-serif;
    }
    canvas {
      display: block;
      position: fixed;
      top: 0;
      left: 0;
      z-index: -1;
    }
  </style>
</head>
<body>
  <canvas id="orbitCanvas"></canvas>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.13.2/gsap.min.js"></script>
  <script>
    const canvas = document.getElementById('orbitCanvas');
    const ctx = canvas.getContext('2d');

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    let mouse = { x: canvas.width/2, y: canvas.height/2 };
    let scrollFactor = 0;
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;

    // Load your logo image
    const logo = new Image();
    logo.src = 'images/logiccloudai.png'; // Replace with your logo file path
    const logoSize = 40;

    const planets = [
      { radius: 90, gradientColors: ['#6DD5FA','#2980B9'], depth: 0.6 },
      { radius: 70, gradientColors: ['#4CA1AF','#2C3E50'], depth: 1 }
    ];

    const satellites = [];
    const numSatellites = 6;
    for (let i = 0; i < numSatellites; i++) {
      satellites.push({
        angle: Math.random() * Math.PI * 2,
        radius: planets[1].radius + 50 + i * 25,
        speed: 0.008 + Math.random() * 0.015,
        size: 5 + Math.random() * 5,
        color: `hsl(${Math.random()*360}, 100%, 75%)`,
        depth: Math.random() * 0.5 + 0.75,
        trail: [],
        logo: i < 3 ? true : false // First 3 satellites have logos
      });
    }

    const stars = [];
    const numStars = 200;
    for (let i = 0; i < numStars; i++) {
      stars.push({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        size: Math.random() * 2,
        alpha: Math.random(),
        delta: Math.random() * 0.02
      });
    }

    function drawStars() {
      stars.forEach(star => {
        star.alpha += star.delta;
        if(star.alpha > 1) { star.alpha = 1; star.delta *= -1; }
        if(star.alpha < 0.2) { star.alpha = 0.2; star.delta *= -1; }
        ctx.beginPath();
        ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255,255,255,${star.alpha})`;
        ctx.fill();
        ctx.closePath();
      });
    }

    function drawFlag(satX, satY, text) {
      const flagWidth = 80;
      const flagHeight = 25;
      ctx.beginPath();
      ctx.fillStyle = '#FFD700';
      ctx.fillRect(satX + 10, satY - flagHeight/2, flagWidth, flagHeight);
      ctx.strokeStyle = '#FFF';
      ctx.strokeRect(satX + 10, satY - flagHeight/2, flagWidth, flagHeight);
      ctx.closePath();

      ctx.fillStyle = '#000';
      ctx.font = 'bold 14px sans-serif';
      ctx.fillText(text, satX + 15, satY + 5);
    }

    function draw() {
      ctx.fillStyle = 'rgba(10,10,42,0.3)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      drawStars();

      const offsetX = (mouse.x - centerX) * 0.02;
      const offsetY = (mouse.y - centerY) * 0.02;

      planets.forEach(planet => {
        const grad = ctx.createRadialGradient(centerX + offsetX*planet.depth, centerY + offsetY*planet.depth, 0,
                                              centerX + offsetX*planet.depth, centerY + offsetY*planet.depth, planet.radius);
        grad.addColorStop(0, planet.gradientColors[0]);
        grad.addColorStop(1, planet.gradientColors[1]);
        ctx.beginPath();
        ctx.arc(centerX + offsetX*planet.depth, centerY + offsetY*planet.depth, planet.radius, 0, Math.PI*2);
        ctx.fillStyle = grad;
        ctx.fill();
        ctx.closePath();
      });

      satellites.forEach(sat => {
        sat.angle += sat.speed + scrollFactor * 0.002;

        const dx = mouse.x - (centerX + offsetX * sat.depth + sat.radius * Math.cos(sat.angle));
        const dy = mouse.y - (centerY + offsetY * sat.depth + sat.radius * Math.sin(sat.angle));
        const dist = Math.sqrt(dx*dx + dy*dy);
        let hoverOffsetX = 0;
        let hoverOffsetY = 0;
        if(dist < 100){
          hoverOffsetX = -dx/10;
          hoverOffsetY = -dy/10;
        }

        const satX = centerX + offsetX * sat.depth + sat.radius * Math.cos(sat.angle) + hoverOffsetX;
        const satY = centerY + offsetY * sat.depth + sat.radius * Math.sin(sat.angle) + hoverOffsetY;

        sat.trail.push({ x: satX, y: satY });
        if (sat.trail.length > 25) sat.trail.shift();

        for (let i = 0; i < sat.trail.length - 1; i++) {
          const p1 = sat.trail[i];
          const p2 = sat.trail[i+1];
          ctx.beginPath();
          ctx.moveTo(p1.x,p1.y);
          ctx.lineTo(p2.x,p2.y);
          ctx.strokeStyle = `rgba(255,255,255,${i/sat.trail.length*0.3})`;
          ctx.lineWidth = 2;
          ctx.stroke();
          ctx.closePath();
        }

        if(sat.logo){
          ctx.drawImage(logo, satX - logoSize/2, satY - logoSize/2, logoSize, logoSize);
          drawFlag(satX, satY, "LogicCloudAI"); // optional flag
        } else {
          ctx.beginPath();
          ctx.arc(satX, satY, sat.size, 0, Math.PI*2);
          const gradient = ctx.createRadialGradient(satX,satY,0,satX,satY,sat.size*2);
          gradient.addColorStop(0,sat.color);
          gradient.addColorStop(1,'rgba(255,255,255,0)');
          ctx.fillStyle = gradient;
          ctx.fill();
          ctx.closePath();
        }

        ctx.beginPath();
        ctx.arc(centerX + offsetX * sat.depth, centerY + offsetY * sat.depth, sat.radius, 0, Math.PI*2);
        ctx.strokeStyle = 'rgba(255,255,255,0.05)';
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.closePath();
      });

      requestAnimationFrame(draw);
    }

    draw();

    window.addEventListener('mousemove', e => {
      mouse.x = e.clientX;
      mouse.y = e.clientY;
    });

    window.addEventListener('scroll', () => {
      scrollFactor = window.scrollY / window.innerHeight;
    });

    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    });
  </script>
</body>
</html>
